import { StaticImplements } from "./deps.ts"

export type NodeKind = symbol
export interface ASTNode<T = any> {
	kind: NodeKind
	value: T
	cursor: number
}
export type ASTNodeTerminal<T> = ASTNode<T>
export type ASTNodeComposite<TA extends Array<ASTNode>> = ASTNode<TA>

/** a `ParseFunction` is a function, specific to a certain {@link NodeKind | kind of node},
 * which can generate an {@link ASTNode} from a stream of input tokens, starting from the specific `cursor` position.
 * if it fails to parse, it should return `undefined`
 * 
 * @typeParam N the specific interface of {@link ASTNode} generated by this parser
*/
export type ParserFunction<N extends ASTNode = any> = (cursor: number, input: Token[]) => N | undefined

// provided by the `Parser`
export type UnParserFunction<N extends ASTNode = any> = (context: {}, input: N) => Token[] | undefined


/** a `Parser` is a class bound to producing only a specific type of {@link N | ASTNode}.
 * the {@link parse} static method should be able to parse a stream of input tokens into its designated {@link N | ASTNode} type, or it should fail.
 * the {@link unparse} static method should be able to unparse a given `ASTNode` back into a stream of source code text.
*/
export interface Parser<N extends ASTNode = any> {
	new(): N
	// /** this is for registering new tokens into the compiler context, and/or depending on a certain existing one. */
	// tokens?: Record<string, TokenKind>
	// tokenize: TokenizerFunction<T>
	parse: ParserFunction<N>
	unparse: any
}

class A implements StaticImplements<Parser<StmtNode>, typeof A> {
	kind = Symbol()
	children = []
	constructor() {

	}
	static tokens = [Symbol(),]
	static tokenize = () => [0, this.tokens[0]] as [next_cursor: number, token?: any]
	static parse = () => { return [0, new this()] as [next_cursor: number, node: StmtNode] }
}

export type FeatureFactory<N extends ASTNode = any> = (cctx: CompilerContext) => Parser<N>

