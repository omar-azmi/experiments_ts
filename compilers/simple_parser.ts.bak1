import { SortedArray, Token, Keyword, Identifier, Assignment, Rune, isEmpty } from "./simple_lexer.ts"

type ParseKind = symbol

interface ParseTree<T> {
	kind: ParseKind
	value: T
	cursor: number
}

type ParseFunction<P extends ParseTree<any>> = (cursor: number, input: Token[]) => Iterable<P>

interface Parser<P extends ParseTree<any>> {
	parse: ParseFunction<P>
}

interface ParserMatchConfig {
	kind?: Token["kind"]
	pattern?: ParseKind | string | RegExp
	keep?: boolean
	transform?: () => any
}

class ParserContext {
	private parsers: Map<ParseKind, ParseFunction<any>> = new Map()

	addParser(kind: ParseKind, parser_fn: ParseFunction<any>) {

	}

	/** generate a sequence parser. useful for keeping things short, declarative, and nonredundant. */
	parseSequence(parse_kind: ParseKind, matches: ParserMatchConfig[]): ParseFunction<any> {
		return (function* (this: ParserContext, cursor: number, input: Token[]) {
			const output = { kind: parse_kind, value: [] as Array<any>, cursor: cursor }
			for (const { kind, pattern, keep } of matches) {
				const current_token = input[cursor++]
				if (kind && (kind !== current_token.kind)) { return }
				if (pattern) {
					if (typeof pattern === "string") {
						if (pattern !== current_token.value) { return }
					} else if (pattern instanceof RegExp) {
						if (!pattern.test(current_token.value)) { return }
					} else {
						// TODO: SKIPPING THE COMPLEXITY FOR NOW
						const parsed_patterns = [...this.parsers.get(pattern)!(cursor, input)]
						if (isEmpty(parsed_patterns)) { return }
						cursor = parsed_patterns[0].cursor
					}
				}
				if (keep) {
					output.value.push(current_token.value)
				}
			}
			output.cursor = cursor
			yield output
		}).bind(this)
	}
}


type ParseTree_LetStatement = ParseTree<[id: string, type_id: string, expression: any]>

const parse_kind_let_statement: ParseKind = Symbol("let statement")
const parse_let_statement: ParseFunction<ParseTree_LetStatement> = function* (cursor: number, input: Token[]) {
	const
		let_kw = input[cursor++],
		id = input[cursor++],
		colon = input[cursor++],
		type_id = input[cursor++],
		assignment = input[cursor++],
		parsed_tree: Partial<ParseTree_LetStatement> = {
			kind: parse_kind_let_statement,
		}
	if (
		let_kw.kind === Keyword && let_kw.value === "let" &&
		id.kind === Identifier &&
		colon.kind === Rune && colon.value === ":" &&
		type_id.kind === Identifier &&
		assignment.kind === Assignment && assignment.value === "="
	) {
		const parsed_epression = {}
		parsed_tree.value = [id.value, type_id.value, parsed_epression]
		yield parsed_tree as ParseTree_LetStatement
	}
}

type SequenceGenerator = (
	match0: {
		kind?: TokenKind,
		value?: string,
		keep: boolean | (() => any)
	},
) => (() => {})

